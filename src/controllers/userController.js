const prisma = require('../lib/prisma');
const { updateUserActivityMetrics } = require('./suggestionController');

// Get user profile
exports.getProfile = async (req, res) => {
    try {
        const userId = req.user.id;
        
        // Update user activity timestamp
        await updateUserActivityMetrics(userId);
        
        // Get user with Prisma
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: {
                id: true,
                username: true,
                email: true,
                profile_picture: true,
                posts_count: true,
                follower_count: true,
                total_profile_views: true,
                likes: true,
                subscribers: true,
                recent_searches: true,
                phone1: true,
                phone2: true,
                selected_category: true,
                bio: true,
                status: true,
                role: true,
                last_login: true,
                country_id: true,
                country: {
                    select: {
                        id: true,
                        name: true,
                        code: true,
                        flag_emoji: true
                    }
                }
            }
        });

        // Transform the user object to match expected format
        const transformedUser = user ? {
            ...user,
            fullName: user.username,
            postsCount: user.posts_count,
            followersCount: user.follower_count
        } : null;

        if (!transformedUser) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        // Get following count
        const followingCount = await prisma.follow.count({
            where: {
                followerId: userId
            }
        });
        
        // Get total post views for this user
        const totalPostViews = await prisma.post.aggregate({
            where: {
                user_id: userId
            },
            _sum: {
                views: true
            }
        });
        
        transformedUser.followingCount = followingCount;
        transformedUser.totalPostViews = totalPostViews._sum.views || 0;
        transformedUser.coverPhoto = null; // Add coverPhoto field for consistency
        
        // Add timestamps
        transformedUser.createdAt = new Date().toISOString();
        transformedUser.updatedAt = new Date().toISOString();

        res.json({
            status: 'success',
            data: transformedUser
        });
    } catch (error) {
        console.error('Profile fetch error:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching profile',
            details: error.message
        });
    }
};

/**
 * Update user profile - handles profile picture upload and phone number updates
 * @route PUT /api/user/profile
 * @access Private
 */
exports.updateProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    const { phone1, phone2, bio } = req.body;
    
    // Create an update object with only allowed fields
    const updateData = {};
    if (phone1 !== undefined) updateData.phone1 = phone1;
    if (phone2 !== undefined) updateData.phone2 = phone2;
    if (bio !== undefined) updateData.bio = bio ? String(bio).trim() : null;
    
    // Handle profile picture upload if it exists
    if (req.file) {
      try {
        // File is already saved by the upload middleware (R2 or local storage)
        // Use the URL generated by the middleware
        const localUrl = req.file.r2Url || req.file.localUrl || req.file.supabaseUrl || `/uploads/${req.file.filename}`;
        
        console.log('Profile picture uploaded:', localUrl, req.file.r2Url ? '(R2)' : '(local storage)');
        
        // Add profile picture URL to update data
        updateData.profile_picture = localUrl;
        
      } catch (uploadError) {
        console.error('File upload error:', uploadError);
        return res.status(500).json({
          status: 'error',
          message: 'Failed to upload profile picture',
          error: process.env.NODE_ENV === 'development' ? uploadError.message : undefined
        });
      }
    }
    
    // Only proceed if there are fields to update
    if (Object.keys(updateData).length === 0) {
      return res.status(400).json({
        status: 'error',
        message: 'No valid fields provided for update'
      });
    }
    
    // Update the user with the restricted fields
    const updatedUser = await prisma.user.update({
      where: { id: userId },
      data: updateData,
      select: {
        id: true,
        username: true,
        email: true,
        phone1: true,
        phone2: true,
        profile_picture: true,
        bio: true,
        posts_count: true,
        follower_count: true,
        total_profile_views: true,
        likes: true,
        subscribers: true,
        status: true,
        role: true,
        last_login: true,
        country_id: true,
        country: {
          select: {
            id: true,
            name: true,
            code: true,
            flag_emoji: true
          }
        },
        createdAt: true,
        updatedAt: true
      }
    });
    
    res.status(200).json({
      status: 'success',
      message: 'Profile updated successfully',
      data: updatedUser
    });
    
  } catch (error) {
    console.error('Profile update error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Failed to update profile',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

// Get user statistics
exports.getStatistics = async (req, res) => {
    try {
        const userId = req.user.id;
        const username = req.user.username;

        // Get user data
        const user = await prisma.user.findUnique({
            where: { id: userId },
            select: {
                total_profile_views: true,
                likes: true,
                subscribers: true
            }
        });

        // Get post count
        const postCount = await prisma.post.count({
            where: { user_id: userId }
        });

        // Get comment count
        const commentCount = await prisma.comment.count({
            where: { commentor_id: userId }
        });

        // Get like count
        const likeCount = await prisma.postLike.count({
            where: { user_id: userId }
        });

        res.json({
            status: 'success',
            data: {
                statistics: {
                    posts_count: postCount,
                    total_profile_views: user.total_profile_views,
                    total_likes: user.likes,
                    total_subscribers: user.subscribers,
                    total_comments: commentCount,
                    total_likes_given: likeCount
                }
            }
        });
    } catch (error) {
        console.error('Statistics fetch error:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching statistics'
        });
    }
};

// Get user's recent searches
exports.getRecentSearches = async (req, res) => {
    try {
        const username = req.user.username;
        
        // Use Prisma to get recent searches
        const searches = await prisma.recentSearch.findMany({
            where: { userID: username },
            select: {
                searchTerm: true,
                createdAt: true
            },
            orderBy: {
                createdAt: 'desc'
            },
            take: 10
        });

        res.json({
            status: 'success',
            data: {
                searches: searches
            }
        });
    } catch (error) {
        console.error('Error fetching recent searches:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching recent searches'
        });
    }
};

// Add a search term
exports.addSearchTerm = async (req, res) => {
    console.log(req.body);
    try {

        const username = req.user.username;
        const searchTerm = req.body.search_term;
        console.log(searchTerm);
        
        // Create a new search record using raw SQL
        await prisma.recentSearch.create({
            data: {
                userID: username,
                searchTerm: searchTerm
            }
        });

        // Update user's recent_searches array using raw SQL
        const user = await prisma.user.findUnique({
            where: { username: username },
            select: { recent_searches: true }
        });
        
        if (user) {
            // Get current recent searches or initialize empty array
            let recentSearches = user.recent_searches || [];
            
            // If array is not valid, initialize it
            if (!Array.isArray(recentSearches)) {
                recentSearches = [];
            }
            
            // Remove oldest search if we already have 10
            if (recentSearches.length >= 10) {
                recentSearches = recentSearches.slice(1);
            }
            
            // Add new search term
            recentSearches.push(searchTerm);
            
            // Filter out undefined values before updating
            const filteredSearches = recentSearches.filter(term => term !== undefined && term !== null);
            
            // Update the user with Prisma
            await prisma.user.update({
                where: { username: username },
                data: { recent_searches: filteredSearches }
            });
        }

        res.json({
            status: 'success',
            message: 'Search term added successfully'
        });
    } catch (error) {
        console.error('Error adding search term:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error adding search term',
            details: error.message
        });
    }
};

// Toggle notifications
exports.toggleNotifications = async (req, res) => {
    console.log(req.body);
    try {
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: { notification: true }
        });
        
        if (!user) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }
        
        const updatedUser = await prisma.user.update({
            where: { id: req.user.id },
            data: { notification: !user.notification },
            select: { notification: true }
        });
        res.json({
            status: 'success',
            message: `Notifications ${updatedUser.notification ? 'enabled' : 'disabled'} successfully`
        });
    } catch (error) {

        console.error('Notification toggle error:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error toggling notifications'
        });
    }
};

// Get user notifications
exports.getNotifications = async (req, res) => {
    try {
        // Get user's username first
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: { username: true }
        });

        if (!user || !user.username) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        const notifications = await prisma.notification.findMany({
            where: { userID: user.username },
            orderBy: {
                createdAt: 'desc'
            }
        });

        res.json({
            status: 'success',
            data: { notifications }
        });
    } catch (error) {
        console.error('Notifications fetch error:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching notifications'
        });
    }
};

exports.getCurrentUser = async (req, res) => {
    try {
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: {
                id: true,
                username: true,
                email: true,
                phone1: true,
                phone2: true,
                profile_picture: true,
                bio: true,
                posts_count: true,
                follower_count: true,
                total_profile_views: true,
                likes: true,
                subscribers: true,
                status: true,
                role: true,
                last_login: true,
                country_id: true,
                country: {
                    select: {
                        id: true,
                        name: true,
                        code: true,
                        flag_emoji: true
                    }
                },
                createdAt: true,
                updatedAt: true
            }
        });

        if (!user) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        res.json({
            status: 'success',
            data: user
        });
    } catch (error) {
        console.error('Error getting current user:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching user data'
        });
    }
};

exports.getAllUsers = async (req, res) => {
    try {
        const users = await prisma.user.findMany({
            select: {
                id: true,
                username: true,
                email: true,
                phone1: true,
                phone2: true,
                profile_picture: true,
                bio: true,
                posts_count: true,
                follower_count: true,
                total_profile_views: true,
                likes: true,
                subscribers: true,
                status: true,
                role: true,
                last_login: true,
                country_id: true,
                country: {
                    select: {
                        id: true,
                        name: true,
                        code: true,
                        flag_emoji: true
                    }
                },
                createdAt: true,
                updatedAt: true
            }
        });

        // Calculate total post views for each user
        const userViews = await prisma.post.groupBy({
            by: ['user_id'],
            _sum: {
                views: true
            }
        });

        const totalViewsMap = {};
        userViews.forEach(view => {
            totalViewsMap[view.user_id] = view._sum.views || 0;
        });

        // Enhance users with total post views
        const enhancedUsers = users.map(user => ({
            ...user,
            totalPostViews: totalViewsMap[user.id] || 0
        }));

        res.json({
            status: 'success',
            data: enhancedUsers
        });
    } catch (error) {
        console.error('Error getting all users:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching users'
        });
    }
};

exports.getUser = async (req, res) => {
    try {
        const user = await prisma.user.findUnique({
            where: { id: req.params.id },
            select: {
                id: true,
                username: true,
                email: true,
                phone1: true,
                phone2: true,
                profile_picture: true,
                bio: true,
                posts_count: true,
                follower_count: true,
                total_profile_views: true,
                likes: true,
                subscribers: true,
                status: true,
                role: true,
                last_login: true,
                country_id: true,
                country: {
                    select: {
                        id: true,
                        name: true,
                        code: true,
                        flag_emoji: true
                    }
                },
                createdAt: true,
                updatedAt: true
            }
        });

        if (!user) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        res.json({
            status: 'success',
            data: user
        });
    } catch (error) {
        console.error('Error getting user:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching user'
        });
    }
};

exports.updateUser = async (req, res) => {
    try {
        const user = await prisma.user.findUnique({
            where: { id: req.params.id }
        });

        if (!user) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        const { username, primaryPhone, secondaryPhone, isAdmin } = req.body;
        const updatedUser = await prisma.user.update({
            where: { id: req.params.id },
            data: {
                username,
                phone1: primaryPhone,
                phone2: secondaryPhone,
                role: isAdmin ? 'admin' : 'user'
            },
            select: {
                id: true,
                username: true,
                email: true,
                phone1: true,
                phone2: true,
                role: true,
                status: true,
                createdAt: true,
                updatedAt: true
            }
        });

        res.json({
            status: 'success',
            message: 'User updated successfully',
            data: updatedUser
        });
    } catch (error) {
        console.error('Error updating user:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error updating user'
        });
    }
};

exports.deleteUser = async (req, res) => {
    try {
        const user = await prisma.user.findUnique({
            where: { id: req.params.id }
        });

        if (!user) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        await prisma.user.delete({
            where: { id: req.params.id }
        });

        res.json({
            status: 'success',
            message: 'User deleted successfully'
        });
    } catch (error) {
        console.error('Error deleting user:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error deleting user'
        });
    }
};

exports.markAllNotificationsAsRead = async (req, res) => {
    try {
        // Get user's username first
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: { username: true }
        });

        if (!user || !user.username) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }
        
        // Update all unread notifications for the user
        const result = await prisma.notification.updateMany({
            where: { 
                userID: user.username,
                isRead: false
            },
            data: {
                isRead: true
            }
        });
        
        res.json({
            status: 'success',
            message: 'All notifications marked as read',
            data: { count: result.count }
        });
    } catch (error) {
        console.error('Error marking notifications as read:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error marking notifications as read',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

// Mark single notification as read
exports.markNotificationAsRead = async (req, res) => {
    try {
        const { notificationId } = req.params;
        
        // Get user's username first
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: { username: true }
        });

        if (!user || !user.username) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        // Check if notification exists and belongs to user
        const notification = await prisma.notification.findFirst({
            where: {
                id: notificationId,
                userID: user.username
            }
        });

        if (!notification) {
            return res.status(404).json({
                status: 'error',
                message: 'Notification not found'
            });
        }

        // Update notification
        const updatedNotification = await prisma.notification.update({
            where: { id: notificationId },
            data: { isRead: true }
        });

        res.json({
            status: 'success',
            message: 'Notification marked as read',
            data: { notification: updatedNotification }
        });
    } catch (error) {
        console.error('Error marking notification as read:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error marking notification as read',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

// Delete single notification
exports.deleteNotification = async (req, res) => {
    try {
        const { notificationId } = req.params;
        
        // Get user's username first
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: { username: true }
        });

        if (!user || !user.username) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        // Check if notification exists and belongs to user
        const notification = await prisma.notification.findFirst({
            where: {
                id: notificationId,
                userID: user.username
            }
        });

        if (!notification) {
            return res.status(404).json({
                status: 'error',
                message: 'Notification not found'
            });
        }

        // Delete notification
        await prisma.notification.delete({
            where: { id: notificationId }
        });

        res.json({
            status: 'success',
            message: 'Notification deleted successfully'
        });
    } catch (error) {
        console.error('Error deleting notification:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error deleting notification',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

// Delete all notifications
exports.deleteAllNotifications = async (req, res) => {
    try {
        // Get user's username first
        const user = await prisma.user.findUnique({
            where: { id: req.user.id },
            select: { username: true }
        });

        if (!user || !user.username) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        // Delete all notifications for the user
        const result = await prisma.notification.deleteMany({
            where: { 
                userID: user.username
            }
        });

        res.json({
            status: 'success',
            message: 'All notifications deleted successfully',
            data: { count: result.count }
        });
    } catch (error) {
        console.error('Error deleting notifications:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error deleting notifications',
            details: process.env.NODE_ENV === 'development' ? error.message : undefined
        });
    }
};

// Update user interests
exports.updateUserInterests = async (req, res) => {
    try {
        const userId = req.user.id;
        const { interests } = req.body;

        if (!interests || !Array.isArray(interests)) {
            return res.status(400).json({
                status: 'error',
                message: 'Interests must be provided as an array'
            });
        }

        // Limit the number of interests to 10
        const limitedInterests = interests.slice(0, 10);

        // Update user interests using Prisma
        await prisma.user.update({
            where: { id: userId },
            data: {
                interests: limitedInterests,
                updatedAt: new Date(),
                last_active_date: new Date()
            }
        });

        res.json({
            status: 'success',
            message: 'Interests updated successfully',
            data: {
                interests: limitedInterests
            }
        });
    } catch (error) {
        console.error('Error updating interests:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error updating interests',
            details: error.message
        });
    }
};

// Get user profile by ID (for public profile viewing)
exports.getUserProfileById = async (req, res) => {
    try {
        let userId = req.params.id;
        
        // Validate UUID format - ensure it's a proper UUID
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(userId)) {
            return res.status(400).json({
                status: 'error',
                message: 'Invalid user ID format'
            });
        }
        
        const currentUserId = req.user ? req.user.id : null;

        // Get user with Prisma
        const user = await prisma.user.findUnique({
            where: {
                id: userId
            },
            select: {
                id: true,
                username: true,
                email: true,
                profile_picture: true,
                bio: true,
                posts_count: true,
                follower_count: true,
                total_profile_views: true,
                status: true,
                country_id: true,
                country: {
                    select: {
                        id: true,
                        name: true,
                        code: true,
                        flag_emoji: true
                    }
                },
                createdAt: true,
                updatedAt: true
            }
        });

        if (!user || user.status !== 'active') {
            return res.status(404).json({
                status: 'error',
                message: 'User not found or account is inactive'
            });
        }

        // Convert to expected format
        const userData = {
            id: user.id,
            username: user.username,
            email: user.email,
            fullName: user.username,
            profilePicture: user.profile_picture,
            bio: user.bio,
            postsCount: user.posts_count,
            followersCount: user.follower_count,
            coverPhoto: null,
            country: user.country,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
        };

        // Get following count
        const followingCount = await prisma.follow.count({
            where: {
                followerId: userId
            }
        });
        
        userData.followingCount = followingCount;

        // Check if current user is following this profile
        let isFollowing = false;
        if (currentUserId) {
            const followExists = await prisma.follow.findFirst({
                where: {
                    followerId: currentUserId,
                    followingId: userId
                }
            });
            isFollowing = !!followExists;
        }

        userData.isFollowing = isFollowing;

        // Update profile view count if not viewing own profile
        if (currentUserId !== userId) {
            await prisma.user.update({
                where: { id: userId },
                data: {
                    total_profile_views: {
                        increment: 1
                    }
                }
            });
        }

        // Remove underscore fields that were renamed
        delete userData.profile_picture;
        delete userData.posts_count;
        delete userData.follower_count;

        res.json({
            status: 'success',
            data: userData
        });
    } catch (error) {
        console.error('Error fetching user profile:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching user profile'
        });
    }
};

// Get user posts
exports.getUserPostsById = async (req, res) => {
    try {
        let userId = req.params.id;
        
        // Validate UUID format - ensure it's a proper UUID
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(userId)) {
            return res.status(400).json({
                status: 'error',
                message: 'Invalid user ID format'
            });
        }
        
        const currentUserId = req.user ? req.user.id : null;
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        const offset = (page - 1) * limit;
        const status = req.query.status || 'approved'; // Default to approved if no status specified

        // Validate status parameter
        const validStatuses = ['approved', 'pending', 'rejected', 'draft', 'active', 'suspended'];
        if (status && !validStatuses.includes(status)) {
            return res.status(400).json({
                status: 'error',
                message: 'Invalid status parameter. Must be one of: approved, pending, rejected, draft, active, suspended'
            });
        }

        // Map user-friendly status names to enum values
        const statusMap = {
            'pending': 'draft',
            'approved': 'active',
            'rejected': 'suspended',
            'draft': 'draft',
            'active': 'active',
            'suspended': 'suspended'
        };

        // Build where clause based on status parameter
        const whereClause = { user_id: userId };
        if (status) {
            whereClause.status = statusMap[status] || status;
        }

        // Use Prisma to get posts with count
        const [posts, totalCount] = await Promise.all([
            prisma.post.findMany({
                where: whereClause,
                include: {
                    category: {
                        select: {
                            name: true
                        }
                    },
                    user: {
                        select: {
                            username: true,
                            profile_picture: true
                        }
                    }
                },
                orderBy: {
                    createdAt: 'desc'
                },
                take: limit,
                skip: offset
            }),
            prisma.post.count({
                where: whereClause
            })
        ]);

        // Transform to match the expected format
        const formattedPosts = posts.map(post => ({
            id: post.id,
            title: post.title,
            description: post.description,
            videoUrl: post.video_url,
            mediaType: post.video_url ? 'video' : 'image',
            created_at: post.createdAt,
            likesCount: post.likes || 0,
            category_id: post.category_id,
            categoryName: post.category?.name,
            commentsCount: post.comment_count || 0,
            authorName: post.user?.username,
            authorProfilePicture: post.user?.profile_picture
        }));

        // Check if user liked these posts
        if (currentUserId && formattedPosts.length > 0) {
            const postIds = formattedPosts.map(post => post.id);
            
            const likedPosts = await prisma.postLike.findMany({
                where: {
                    user_id: currentUserId,
                    post_id: {
                        in: postIds
                    }
                },
                select: {
                    post_id: true
                }
            });
            
            const likedPostIdSet = new Set(likedPosts.map(like => like.post_id));
            
            // Add isLiked flag to each post
            formattedPosts.forEach(post => {
                post.isLiked = likedPostIdSet.has(post.id);
            });
        }

        const hasMore = offset + formattedPosts.length < totalCount;

        res.json({
            status: 'success',
            data: {
                posts: formattedPosts,
                hasMore,
                totalCount
            }
        });
    } catch (error) {
        console.error('Error fetching user posts:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching user posts'
        });
    }
};

// Get user approved posts only (for external profiles)
exports.getUserApprovedPosts = async (req, res) => {
    try {
        let userId = req.params.id;
        
        // Validate UUID format - ensure it's a proper UUID
        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        if (!uuidRegex.test(userId)) {
            return res.status(400).json({
                status: 'error',
                message: 'Invalid user ID format'
            });
        }
        
        const currentUserId = req.user ? req.user.id : null;
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        const offset = (page - 1) * limit;

        // Use Prisma to get approved posts with count
        const [posts, totalCount] = await Promise.all([
            prisma.post.findMany({
                where: {
                    user_id: userId,
                    status: 'active'
                },
                include: {
                    category: {
                        select: {
                            name: true
                        }
                    },
                    user: {
                        select: {
                            username: true,
                            profile_picture: true
                        }
                    }
                },
                orderBy: {
                    createdAt: 'desc'
                },
                take: limit,
                skip: offset
            }),
            prisma.post.count({
                where: {
                    user_id: userId,
                    status: 'active'
                }
            })
        ]);

        // Transform to match the expected format
        const formattedPosts = posts.map(post => ({
            id: post.id,
            title: post.title,
            description: post.description,
            videoUrl: post.video_url,
            mediaType: post.video_url ? 'video' : 'image',
            created_at: post.createdAt,
            likesCount: post.likes || 0,
            category_id: post.category_id,
            categoryName: post.category?.name,
            commentsCount: post.comment_count || 0,
            authorName: post.user?.username,
            authorProfilePicture: post.user?.profile_picture
        }));

        // Check if user liked these posts
        if (currentUserId && formattedPosts.length > 0) {
            const postIds = formattedPosts.map(post => post.id);
            
            const likedPosts = await prisma.postLike.findMany({
                where: {
                    user_id: currentUserId,
                    post_id: {
                        in: postIds
                    }
                },
                select: {
                    post_id: true
                }
            });
            
            const likedPostIdSet = new Set(likedPosts.map(like => like.post_id));
            
            // Add isLiked flag to each post
            formattedPosts.forEach(post => {
                post.isLiked = likedPostIdSet.has(post.id);
            });
        }

        const hasMore = offset + formattedPosts.length < totalCount;

        res.json({
            status: 'success',
            data: formattedPosts
        });
    } catch (error) {
        console.error('Error fetching user approved posts:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error fetching user approved posts'
        });
    }
};

/**
 * Update user's country
 */
exports.updateUserCountry = async (req, res) => {
    try {
        const userId = req.user?.id || req.user?.userId;
        if (!userId) {
            return res.status(401).json({
                status: 'error',
                message: 'Unauthorized: missing user context'
            });
        }
        const { country_id } = req.body;

        // Validate country_id if provided
        if (country_id !== null && country_id !== undefined) {
            const countryExists = await prisma.country.findUnique({
                where: { id: parseInt(country_id) }
            });

            if (!countryExists) {
                return res.status(400).json({
                    status: 'error',
                    message: 'Invalid country ID'
                });
            }
        }

        // Ensure user exists
        const existingUser = await prisma.user.findUnique({
            where: { id: userId },
            select: { id: true }
        });
        if (!existingUser) {
            return res.status(404).json({
                status: 'error',
                message: 'User not found'
            });
        }

        // Update user's country
        const updatedUser = await prisma.user.update({
            where: { id: userId },
            data: { country_id: country_id ? parseInt(country_id) : null },
            select: {
                id: true,
                username: true,
                country_id: true,
                country: {
                    select: {
                        id: true,
                        name: true,
                        code: true,
                        flag_emoji: true
                    }
                }
            }
        });

        res.json({
            status: 'success',
            message: 'Country updated successfully',
            data: {
                user: updatedUser
            }
        });

    } catch (error) {
        console.error('Update user country error:', error);
        res.status(500).json({
            status: 'error',
            message: 'Error updating country'
        });
    }
};
